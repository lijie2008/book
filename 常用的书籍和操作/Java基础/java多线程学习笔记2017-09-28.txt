关注这个博客：http://www.cnblogs.com/lcngu/category/780217.html

1. JVM调度线程的机制是： 基于优先级的抢先调度机制

2. 注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作

3. Thread.yield() 让相同优先级的线程之间能适当的轮转执行

4. 实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

5. Thread.join() 线程的加入join() 是对线程栈导致的结果是线程栈发生了变化

调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。

6. 线程离开运行状态的方法

	6.1 线程的run()方法完成。

	6.2 在对象上调用wait()方法（不是在线程上调用）。

	6.3 线程不能在对象上获得锁定，它正试图运行该对象的方法代码。

	6.4 线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。
	
7. 线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。

8. 锁和同步

Java中每个对象都有一个内置锁

当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。

获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。

当程序运行到synchronized同步方法或代码块时才该对象锁才起作用。

一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。

这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。

释放锁是指持锁线程退出了synchronized同步方法或代码块。

关于锁和同步，有一下几个要点：

1）、只能同步方法，而不能同步变量和类；

2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，

直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。

5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

6）、线程睡眠时，它所持的任何锁都不会释放。

7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。

8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。

9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁

9. 要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。

静态方法 类似 synchronized(xxx.class) - 类上锁 只要是相同类都会阻塞 而实例锁 对象锁 必须是 对象 或者 实例

10. 方法锁 对象锁 静态方法锁  -  注意锁的是 对象 、类 、 OBJ

11. 总结

1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。

2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。

3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。

4、对于同步，要时刻清醒在哪个对象上同步，这是关键。

5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。

6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。

7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。

12. JAVA线程的交互

 void notify() 
          唤醒在此对象监视器上等待的单个线程。
          
 void notifyAll() 
          唤醒在此对象监视器上等待的所有线程。
          
 void wait() 
          导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法。
          
当然，wait()还有另外两个重载方法：

 void wait(long timeout) 
          导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法，或者超过指定的时间量。 
 void wait(long timeout, int nanos) 
          导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
          
关于等待/通知，要记住的关键点是：

必须从同步环境内调用wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。

wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，

他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，

直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。

线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者

13. wait 和 notify配合使用 ，wait可以释放它上的锁， 但是notify并不会释放锁 所以不会立马唤醒当前线程 

千万注意：

当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。

然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程仍然在完成同步代码，

则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。

实际上，上面这个代码中，我们期望的是读取结果的线程在计算线程调用notifyAll()之前等待即可。

但是，如果计算线程先执行，并在读取结果线程等待之前调用了notify()方法，

那么又会发生什么呢？这种情况是可能发生的。因为无法保证线程的不同部分将按照什么顺序来执行。

幸运的是当读取线程运行时，它只能马上进入等待状态----它没有做任何事情来检查等待的事件是否已经发生。

  ----因此，如果计算线程已经调用了notifyAll()方法，那么它就不会再次调用notifyAll()，
  
  ----并且等待的读取线程将永远保持等待。这当然是开发者所不愿意看到的问题。
  
通常，解决上面问题的最佳方式是将

Java线程：线程的调度 - 休眠

线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。

14. 信号量 - Semaphore

Java的信号量实际上是一个功能完毕的计数器，对控制一定资源的消费与回收有着很重要的意义，

信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等，

这里总是在强调“数目”二字，但不能指出来有哪些在等待，哪些资源可用

15. 条件变量 - Condition - 只能和 Lock对象配合使用

16. ThreadLocal 类似于一个 Map 用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。

Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。

缓存一致性问题： 主存 和 高速缓存 数据 是 读入 - 修改 - 写入主存 单线程肯定正确 但是多线程 可能读入的数据就不对

　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

　　2）禁止进行指令重排序。


　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。

　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

　　但是用volatile修饰之后就变得不一样了：

　　第一：使用volatile关键字会强制将修改的值立即写入主存；

　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；

　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。

　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，

		然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
		
		
		volatile 保证可见性 显而易见 但是原子性 无法保证
		
		
		信号灯可以由一个线程使用，然后由另一个线程来进行释放，而锁只能由同一个线程启动和释放，不然就好发生死锁，这一点需要格外注意。
		
		